操作系统

揭开

图灵机 ----> 通用图灵机 ------>  冯诺依曼的计算机结构

计算机由 计算机五大部件组成：输入设备、输出设备、存储器、运算器、控制器

 **取指执行**



## 4、操作系统接口

**接口：连接俩个东西、信号转移、屏蔽细节**

上层应用是通过什么进入内核的？依靠的就是操作系统

### 1、什么是操作系统的接口

连接上层用户和操作系统软件的命令

命令：

- 命令行
- 图形按钮
- 应用程序

**shell也是一段程序**

```shell
//不断的等着用户敲入门命令
调用使用的Scanf来调用命令，申请cpu
fork()
```



**图形按钮**

消息队列

**调用各种函数**，

用户使用计算机：通过程序（应用软件）

- 操作系统接口：连接操作系统和应用软件就是接口；使用c语言等来连接

  ```c
  //普通的c代码加上重要的函数
  #include<stdio.h>
  int main( int argc,char* argv[]){
      printf("ECHO:%s\n",argv[1]);
  }
  printf 就是这种重要的函数
  ```

- 所以操作系统提供了这样的重要函数

  - 重要函数就是操作系统接口：接口表现为函数调用，又由系统提供，所以称为**系统调用**

系统调用

- POSIX:（IEEE制定的一个标准族）有重要的函数都是啥
- 任务管理
  - **fork**：创建一个进程
  - execl：运行一个可执行程序
  - pthread_create：创建一个线程
- 文件系统
  - **open**：打开一个文件或者目录
  - **excces**：返回值，表示没有权限
  - mode_t st_mode：文件头结构：文件属性

printf实际是调用了write

##  5、系统调用的实现

接口背后的故事

把内存分成俩个区域

- 用户段
- 内核段

DPL是形容目标段，特权级：0表示内核态，3表示用户态

CPL是当前的特权级

当目标的特权级大于等于当前的特权级的时候才可以访问地址，调用jmp，mov



硬件提供了“主动进入内核的方法"

对于Intel 86 ，那就是中断指令 int

- **int指令将使cs中的cpl改成0，“进入内核”**
- 这是用户程序发动的调用内核代码的为唯一方式
- 系统调用的核心：
  1. 用户程序中包含一段包含 int 指令的代码
  2. 操作系统写中断处理，获得想调程序的编号
  3. 操作系统根据编号执行相应代码

必须是 int 0x80

会有一个系统调用号

## 6、操作系统历史

### Linux

- 1955~1965 **IBSYS** 

  计算机非常昂贵，上古神机 IBM7094

  - 计算机使用原则：只专注于计算
  - 批处理操作系统
  - IBSYS监控系统：当时的操作系统可以说是一个监控系统，进行改错

- 1965 ~ 1980  **IBSYS 到 IBM OS/360** 

  计算机开始进入多个行业：科学计算，银行

  - 需要让一台计算机干多件事
  - 多道程序
  - 作业之间的切换和调度变成核心：因为既有IO任务，又有计算任务，需要让CPU忙碌
  - 典型代表：IBM OS/360 (360表示全方位服务)
  - PS：多进程结构和进程管理概念萌芽！

- 1965 ~ 1980 **IBM OS/360 到 MULTICS**  

  计算机进入多个行业，使用人数增加

  - 如果每个人启动一个作业，作业之间快速任务
  - 分时系统
  - 代表：MIT MULTICS 
  - 核心任务依旧是**任务切换**，但是资源复用的思想对操作系统影响很大，**虚拟内存就是一种复用**

- 1980 ~ 1990 **MULTICS  到 Unix**

  小型化计算机出现，PDP-1 

  - 越来越多的个人可以使用计算机
  - 1969：贝尔实验室等人在一台没人使用的PDP-7上开发一个简化的MULTICS，就是后来的UNIX
  - UNIX是一个简化的MULTICS，核心概念差不多，但更灵活和成功

- 1990 ~ 2000 **Unix 到 linux** 

  1981年，IBM退出IBM PC；个人计算机开始普及

  - 很多人可以用计算机并解除UNIX
  - 发布了MINIX（类似UNIX）用于教学
  - Linus学习minix，做出小Linux
  - 1994年，Linux1.0 发布并采用GPL协议，1998年以后**互联网世界里展开了异常历史性的linux产业化运动** 



总结：历史要开始让人明智了

核心思想、技术：

- 用户通过执行程序来使用计算机（吻合冯诺依曼的思想）

- 作为管理者，操作系统就是要让多个程序合理推进，就是**进程管理**
- 多进程（用户）推进时需要内存复用等等

软件实现：

- 对于操作系统，现实很重要 OS/360 ---> UNIX
- 要真正的群体智慧 UNIX ---> Linux

**多进程结构是操作系统基本图谱**

**对于操作系统，实现概念远比理解概念重要**

任务：**掌握操作系统的多进程图谱并实现它**



### Windows

历史是多线条的，PC与DOS

PC机的诞生一定会导致百花齐放。IBM退出PC，自然要给这样的一个机器配一个操作系统

- 1975年Digital Research 为Altair 8800开发了操作系统 CP/M
- CP/M：写命令让用户用，执行命令对应的程序，单任务执行
- 1980出现了8086 16位芯片，从CP/M基础上开发了**QDOS**

QDOS 到 MS-DOS，比尔盖茨进入战场

- 1975年，为Altair 8800 开发了BASIC解释器，开创微软
- 开发FAT管理磁盘
- **QDOS 成功在于以 CP/M为基础将 BASIC 和 FAT 包含了进来**
- 1980年IBM与微软合作；1981年微软买下QDOS，改名**MS-DOS**（Disk OS），和IBM PC打包一起出售

MS-DOS 到 Windows ，MS-DOS的磁盘、文件、命令让使用更方便，但是似乎可以更方便

- 1989年，MS-DOS 4.0出现，支持了鼠标和键盘，此时MS-DOS几乎被放弃
- Windows3.0大获成功
- **文件、开发环境、图形界面对于OS的重要性**

### Mac OS 和IOS

1984年苹果推出PC处理器使用IBM、Intel或者AMD等，核心在于屏幕、能耗等

- 与Mac机一起发布了SystemX系统，一上来就是GUI界面
- System 7 之后改名Mac OS 8
- 2007年发布 IOS ，核心依然是Mac OS ，专为移动设备，如手势等
- Mac OS核心是UNIX，专注于界面、文件、媒体等和用户有关你的内容



### 总结历史

**历史让人明智**

核心思想、技术：

- 依然是程序执行、多进程、程序执行带动其他设备使用的基本结构
- 但用户的使用感觉倍加重视了：各种文件、编程环境、图形界面

软件实现：

- 如何通过文件存储文件、执行代码、操作屏幕......
- 如何让文件和操作变成图标、点击或者触碰......

任务：

1. 掌握、实现操作系统的多进程图谱
2. 掌握、实现操作系统的文件操作视图

## 7、我们的任务

进程View

- CPU管理
- 内存管理

文件View

- 终端设备管理
- 磁盘管理

## 8、CPU管理的直观想法

多进程图像是通过**管理CPU**来实现的

**管理CPU,先使用CPU**

- CPU的工作原理 

  - 自动的取指执行
  - 设定好 PC 初值就行！

  **这样做的问题？**

  IO指令工作是非常的慢，所以CPU在IO指令工作的时候需要等待，

  当执行过程中不能进行的时候**切到另外一个程序**，多道程序、交替执行

- **一个CPU上交替的执行多个程序：并发**

  - 如何做到？修改寄存器PC就行了吗？

    需要切出到其他程序的时候，记录当时的数据，每个程序都把**数据存放在PCB中**

- **进程是进行（执行）中的程序**

  - 进程有开始、结束，程序没有
  - 进程会走走停停，走停对程序无意义
  - 进程需要记录ax、bx，程序不用

## 9、多进程图像

### 多进程如何组织？

- Process Control Block ：用来记录进程信息的数据结构

  用PCB来形成就绪队列、等待队列

- 进程的状态

  新建态、就绪态、运行态、阻塞态、终止态

  能够给出进程的生命期的清晰描述

  是认识操作系统进程管理的一个窗口

  <img src="C:\Users\zfx\AppData\Roaming\Typora\typora-user-images\image-20220302174733789.png" alt="image-20220302174733789" style="zoom:50%;" />

### 多进程如何切换

### 多进程如何交替？



2、如何实现多进程图像

schedule(); 灵魂中的灵魂

getNext 调度

switch_to 进程切换

**进程调度**

> FIFO 

- FIFO 显然是公平的策略
- FIFO 显然没有考虑进程执行的任务的区别

> Priority

- 优先级如何评定

**多进程如何影响**

进程间相互读取

解决方法：映射表

不同进程有不同的映射表

### **多进程如何合作**

-  给操作的时候加锁

## 10、用户级线程

**线程的切换**

一个执行指令到另一个指令，映射表是实际的资源

**是不是可以资源不同而切换指令序列**

这就是线程：保留了并发的优点，避免了进程切换代价

问题：

> 多个执行序列 + 一个地址空间是否有用？

例子：**网页浏览器**

- 一个线程用来服务器接收数据
- 一个线程用来显示文本
- 一个线程用来处理图片
- 一个线程用来显示图片

调用函数切出，**Yield**，

进程切换的核心是Yield

- 需要知道切换时需要是个什么样子
- Create就是要创造出第一次切换时应该的样子

**二个线程不能共用一个栈，会出错，**

TCB CPU里寄存器：用来记住栈

主要是使用俩个栈

**创建线程：主要是申请栈，申请TCB，关联栈和TCB**

> 什么是用户级线程 -- Yield是用户程序

如果用户级线程的某个线程进入内核并阻塞，会导致卡顿，因为内核不认识用户的线程

**内核级线程会进入内核，内核知道TCB**

## 11、内核级线程

**进程要封闭资源，要访问文件，所以没有用户级的进程**

和多核有关

> 和用户级相比，核心级线程有什么不同？

ThreadCreate是系统调用，内核管理TCB，内核负责切换线程

如何切换成型？-内核栈，TCB

- **一个栈到一套栈；两个栈道两套栈**

> 用户栈和内核栈之间的关联

进入内核的唯一方法就是中断

INT 中断进栈

IRET 返回 

TCB：

switch_to的五段论

- 中断入口：（进入切换）

  ``call 中断处理``

- 中断处理：（引发切换）

  ``schedule()；``

- schedule

  ``call switch_to;``

- 内核栈的切换：switch_to

  ``ret``

- 中断出口：（第二级切换）

  ``iret`









