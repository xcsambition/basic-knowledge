## 数据结构与算法

数据结构：

- 队列
- 栈
- 并查集（哈希表）
- 数组
- 链表
- 二叉树
- 图

算法：

- 深度优先
- 广度优先
- 双指针
- 贪心算法
- 动态规划

## 栈和队列

### 1、用栈实现队列

```java
class MyQueue {
    Stack<Integer> stack1;
    Stack<Integer> stack2;


    public MyQueue() {
        stack1 = new Stack<>();
        stack2 = new Stack<>();
    }
    
    public void push(int x) {
        stack1.push(x);

    }
    
    public int pop() {
        if(stack2.isEmpty()){
            while(!stack1.isEmpty()){
                stack2.push(stack1.pop());
            }
        }
        return stack2.pop();
        


    }
    
    public int peek() {
        if(stack2.isEmpty()){
            while(!stack1.isEmpty()){
                stack2.push(stack1.pop());
            }
        }
        return stack2.peek();
    }
    
    public boolean empty() {
        if(stack2.isEmpty()){
            while(!stack1.isEmpty()){
                stack2.push(stack1.pop());
            }
        }
        return stack2.isEmpty();
    }
}
```





## 数组

## 链表

### 1、翻转链表

[翻转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

次数：5

递归：

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        
        return reverseList(null,head);
    }

    public ListNode reverseList(ListNode pre,ListNode curr) {
        if(curr !=null){         
                ListNode next = curr.next;
                curr.next = pre;
                return reverseList(curr,next);
        }
        return pre;
    }
}
```

迭代：

```java
class Solution {
    public ListNode reverseList(ListNode head) {

      
        ListNode curr = head;
        ListNode pre = null;
        ListNode next = null;
        while(curr!=null){
            next = curr.next;
            curr.next = pre;
            pre = curr;
            curr = next;
        }
        return pre;
    }
}
```





## 哈希表

## 滑动窗口

[解析滑动窗口]([[滑动窗口真滴简单!\] 闪电五连鞭带你秒杀12道中档题 (附详情解析) - 无重复字符的最长子串 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/yi-ge-mo-ban-miao-sha-10dao-zhong-deng-n-sb0x/))

## 双指针

### 1、三数之和

[15. 三数之和](https://leetcode-cn.com/problems/3sum/)

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums);
        for(int i=0;i<nums.length-2;i++){
            if(nums[i]>0){
                return result;
            }
            if(i>0 && nums[i] == nums[i-1]){
                continue;
            }



            int left = i+1;
            int right = nums.length-1;
            while(left<right){

                int sum = nums[i] +nums[left] +nums[right];
                if(sum >0){
                    right--;
                }else if(sum<0){
                    left++;
                }else{
                    result.add(Arrays.asList(nums[i],nums[left],nums[right]));
                    
                    while(left<right && nums[left] == nums[left+1]){
                        left++;
                    }
                    while(left<right && nums[right] == nums[right-1]){
                        right--;
                    }

                    right--;
                    left++;
                }
            }
        }
        return result;
    }
}
```



### 1、无重复字符的最长子串

[无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int max = 0;
        Set<Character> set = new HashSet<Character>();
        char[] chars = s.toCharArray();
        for(int right=0,left=0;right<chars.length;){
            if(set.contains(chars[right])){        
                set.remove(chars[left]);
                left++;
            }else{
            set.add(chars[right]);
            right++;
            }
             max = Math.max(right-left,max);
        }
        return max;
    }
}
```

### 2、盛最多水的容器

[11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

```java
class Solution {
    public int maxArea(int[] height) {
        int right =0;
        int left = height.length-1;
        int max=0;
        while(right< left){
            int min = Math.min(height[left],height[right]);
            max = Math.max((left-right)*min,max);
            if(height[right]<height[left]){
                right++;
            }else{
                left--;
            }
            while(height[left]<=min &&right<left){
            --left;
            }
            while(height[right]<=min &&right<left){
                ++right;
            }
        }
        return max;
    }
}
```





## 二叉树

### 1、迭代遍历

#### 前序遍历：

[二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<>();
     if (root == null){
            return res;
    }
    Stack<TreeNode> stack = new Stack<>();
    // Deque<TreeNode> stack = new LinkedList<>();
    // stack.push(root);
    while(root!=null || !stack.isEmpty()){
        
        if(root !=null){
            res.add(root.val);
            stack.push(root);
            root =root.left;
            
        }else{
            root = stack.pop().right;
        }
    }
    return res;
    }
}
```



#### 中序遍历：

[二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

次数：4

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root ==null){
            return res;
        }
        Stack<TreeNode> stack = new Stack<>();
        TreeNode curr = root;
        while(curr!=null || !stack.isEmpty()){
            if(curr!=null){
                stack.push(curr);
                curr = curr.left;
            } else {
                curr = stack.pop();
                res.add(curr.val);
                curr = curr.right;
            }
        }
        return res;
    }
}
```

#### 后序遍历：

[二叉树后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

次数：3

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        Deque<TreeNode> stack = new LinkedList<>();
        List<Integer> list = new ArrayList<>();
        Set<TreeNode> set = new HashSet<>();
        while(root != null || !stack.isEmpty()){
            if(root != null){
                stack.push(root);
                root = root.left;
            }else if(root == null && set.contains(stack.peek())){
                list.add(stack.pop().val);//这里才是处理数据，真正的处理。之前只是遍历
                // root = stack.peek().right;
                //仔细思考为什么这里开始写了，其实就是根据null一直判断栈里面有之前遍历的数据
            }else{
                set.add(stack.peek());
                root = stack.peek().right;
            }
        }
        return list;
    }
}
```

### 2、二叉树的所有路径

[257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

```java
class Solution {
    List<String> res = new ArrayList<>();
    public List<String> binaryTreePaths(TreeNode root) {   
        if(root ==null){
            return res;
        }
        backTracking(root,new StringBuilder());
        return res;
    }
    private void backTracking(TreeNode root,StringBuilder s){
        if(root.left ==null &&root.right ==null){//叶子节点
            res.add(s.append(root.val).toString());
            return;
        }
        //不是叶子节点
        s.append(root.val).append("->");
        if(root.left!=null)backTracking(root.left,new StringBuilder(s));
        if(root.right !=null)backTracking(root.right,new StringBuilder(s));
    }
}

```

### 3、翻转二叉树

思路是把每个节点的左右孩子交换，但是因为交换了左右孩子，不能使用中序遍历，后序遍历最直观，前序遍历相当于是遍历了右左，不过还是遍历了所有。

```java
//前序
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root==null){
            return root;
        }
        TreeNode res = root;
        Deque<TreeNode> stack = new LinkedList<>();
        while(root !=null ||!stack.isEmpty()){
            if(root!=null){
                stack.push(root);
                swap(root);
                root = root.left;
            }else{
                TreeNode node = stack.pop();
                root = node.right;
            }
        }
        return res;
    }
    private void swap(TreeNode root){
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp; 
    }
}

//后序遍历
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root==null){
            return root;
        }
        TreeNode res = root;
        Deque<TreeNode> stack = new LinkedList<>();
        Set<TreeNode> set = new HashSet<>();
        while(root !=null ||!stack.isEmpty()){

             if(root ==null && set.contains(stack.peek())){
                swap(stack.pop());
            }else if(root==null){
                set.add(stack.peek());
                root =stack.peek().right;
            }else if(root!=null){
                stack.push(root);      
                root = root.left;
            }
        }
        return res;
    }
    private void swap(TreeNode root){
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp; 
    }
}
//层序遍历
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root==null){
            return root;
        }
        TreeNode res = root;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            TreeNode node = queue.poll();
            
            if(node.left !=null) queue.offer(node.left);
            if(node.right !=null) queue.offer(node.right);
            swap(node);
        }
        return res;
    }
    private void swap(TreeNode root){
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp; 
    }
}
```

### 4、 最大二叉树

[654. 最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/)

```java
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
         return constructMaximumBinaryTree(nums, 0, nums.length);
    }
     public TreeNode constructMaximumBinaryTree(int[] nums, int leftIndex, int rightIndex) {
         if(rightIndex-leftIndex < 1){
             return null;
         }
         if(rightIndex -leftIndex ==1){
             return new TreeNode(nums[leftIndex]);
         }
         int maxIndex = leftIndex;
         int maxValue = nums[leftIndex];
         for(int i=leftIndex+1;i<rightIndex;i++){
             if(nums[i] >maxValue){
                 maxValue = nums[i];
                 maxIndex = i;
             }
         }
        TreeNode node = new TreeNode(maxValue);
        node.left = constructMaximumBinaryTree(nums,leftIndex,maxIndex);
        node.right = constructMaximumBinaryTree(nums,maxIndex+1,rightIndex);
        return node;
     }
}
```



### 5、从中序与后序遍历序列构造二叉树

[106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

```java
class Solution {
    int[] inorder ;
    int[] postorder;
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        this.inorder = inorder;
        this.postorder = postorder;
        return buildTree(0,inorder.length,0,postorder.length);
    }
    private TreeNode buildTree(int inLeft,int inRight,int postLeft,int postRight){
            if(postRight-postLeft<1){
                return null;
            }
            if(postRight-postLeft==1){
                return new TreeNode(postorder[postLeft]);
            }
            int target = postorder[postRight-1];
            int index = inLeft;
            for(int i=inLeft+1;i<inRight;i++){
                if(inorder[i] ==target){
                    index = i;
                    break;
                }
            }
            TreeNode node = new TreeNode(target);
            node.left = buildTree(inLeft,index,postLeft,postLeft+index-inLeft);
            node.right = buildTree(index+1,inRight,postRight+index-inRight,postRight-1);
            return node;
    }
}
```

### 6、 验证二叉搜索树

[98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

```java
//迭代
class Solution {
    public boolean isValidBST(TreeNode root) {
        return isValidBST(root,Long.MAX_VALUE,Long.MIN_VALUE);

    }
    public boolean isValidBST(TreeNode root,long upper,long lower){
        if(root ==null){
            return true;
        }
        if(root.val >=upper || root.val <= lower){
            return false;
        }
        return isValidBST(root.left,root.val,lower) && isValidBST(root.right,upper,root.val); 
    }
}

//中序遍历
class Solution {
    public boolean isValidBST(TreeNode root) {
        // return isValidBST(root,Long.MIN_VALUE,Long.MAX_VALUE);
        long pre = Long.MIN_VALUE;
        Deque<TreeNode> stack = new LinkedList<>();
        while(root!=null || !stack.isEmpty()){
            if(root !=null){
                stack.push(root);
                root = root.left;
                
            }else{
                TreeNode node = stack.pop();
                if(node.val <=pre){
                    return false;
                }
                pre = node.val;
                root = node.right;
            }
        }
        return true;
    }
```

### 7、根据二叉树创建字符串

[606. 根据二叉树创建字符串](https://leetcode-cn.com/problems/construct-string-from-binary-tree/)

```java
class Solution {
    
    public String tree2str(TreeNode root) {
        StringBuilder sb= new StringBuilder();
        
        dfs(root,sb);
        return sb.toString();
        

    }
    private void dfs(TreeNode root,StringBuilder sb){
        if(root == null){
            return ;
        }
        sb.append(root.val);


        if(root.left ==null && root.right !=null){
            sb.append("()(");
            dfs(root.right,sb);
            sb.append(")");
        }
        if(root.left !=null && root.right==null){
            sb.append("(");
            dfs(root.left,sb);
            sb.append(")");

        }
        if(root.left !=null &&root.right!=null){
            sb.append("(");
            dfs(root.left,sb);
            sb.append(")(");
            dfs(root.right,sb);
            sb.append(")");
        }
    }
}
```

### 2、猜数字大小（记忆化递归）

[375. 猜数字大小 II](https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/)

```java
public int getMoneyAmount(int n) {
        int[][] dp = new int[n+1][n+1];

        return dfs(dp,1,n);
    }
    private int dfs(int[][] dp,int left,int right){
        if(left>=right){
            return 0;
        }
        int res = Integer.MAX_VALUE;
        if(dp[left][right] !=0){
            return dp[left][right];
        }
        for(int i=left;i<=right;i++){
            int cost  = i+ Math.max(dps(dp,left,i-1),dps(dp,i+1,right));

            res=Math.min(res,cost);

        }
        dp[left][right] = res;
        return res;
    }
```

## 回溯

### 1、电话号码的字母组合

[ 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

```java
class Solution {
    List<String> res = new ArrayList<>();
    String [] map = {
        "abc",
        "def",
        "ghi",
        "jkl",
        "mno",
        "pqrs",
        "tuv",
        "wxyz"
    };
    // List<String> res = new ArrayList<>();
    String digits;
    int length;
    public List<String> letterCombinations(String digits) {
        if(digits.equals("")){
            return res;
        }
        this.digits = digits;
        length = digits.length();
        backtracking(new StringBuilder(),0);
        return res;


    }
    private void backtracking(StringBuilder path,int startIndex){
        if(startIndex ==length){
            res.add(path.toString());
            return ;
        }
        String chars = map[digits.charAt(startIndex)-'0'];
        for(int i=0;i<chars.length();i++){
            path.append(chars.charAt(i));
            backtracking(path,startIndex+1);
            path.deleteCharAt(path.length()-1);
        }
    }
}
```

### 2、组合总和

[39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    ArrayList<Integer> path = new ArrayList<>();
    int[] candidates ;
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        Arrays.sort(candidates);
        this.candidates = candidates;
        backtracking(0,target);
        return res;
    }
    private void backtracking(int startIndex,int target){
        if(target<0){
            return ;
        }
        if(0 == target){
            res.add(new ArrayList<Integer>(path));
            return;
        }
        for(int i=startIndex;i<candidates.length;i++){
            if(target < candidates[i]){
                break;
            }
            if(i!=startIndex &&candidates[i] == candidates[i-1]){
                continue;
            }
            path.add(candidates[i]);
            backtracking(i,target - candidates[i]);
            path.remove(path.size()-1);
        }
    }
}

```

### 3、组合总和II

[40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)

```java
class Solution {
        List<List<Integer>> res = new ArrayList<>();
         ArrayList<Integer> path = new ArrayList<>();
           int[] candidates ;
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {

      
        Arrays.sort(candidates);
        this.candidates = candidates;
        backtracking(0,target);
        return res;
    // public List<List<Integer>> combinationSum(int[] candidates, int target) {
        
    // }
    

    }
    private void backtracking(int startIndex,int target){
        if(target<0){
            return ;
        }
        if(0 == target){
            res.add(new ArrayList<Integer>(path));
            return;
        }
        for(int i=startIndex;i<candidates.length;i++){
            if(target < candidates[i]){
                break;
            }
            if(i!=startIndex &&candidates[i] == candidates[i-1]){
                continue;
            }
            path.add(candidates[i]);
            backtracking(i+1,target - candidates[i]);
            path.remove(path.size()-1);
        }
    }
}
```

### 4、组合总和III

[组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> combinationSum3(int k, int n) {
        backtracking(n,k,0,1);
        return res;

    }
    private void backtracking(int targetSum,int k,int sum,int startIndex){
        if(sum>targetSum){
            return ;
        }

        if(path.size() == k){
            if(sum == targetSum){
                res.add(new ArrayList<>(path));
                
            }
            return ;
        }
        for(int i = startIndex;i<=9;i++){
            path.add(i);
            backtracking(targetSum,k,sum+i,i+1);
            path.removeLast();
        }

    }
}
```

### 5、路径总和

2ms->1ms->0ms **理解回溯和删除，引用对象和常量之间删除的区别，提升作用域**

```java
//用到集合，即引用对象，但没有删除
class Solution {
    boolean flag = false;
    public boolean hasPathSum(TreeNode root, int targetSum) {
        List<Integer> path =  new LinkedList<>();
        dfs(root,targetSum,path);
        return flag;
    }
    private void dfs(TreeNode root, int targetSum,List<Integer> path){
        if(root == null){
            return ;
        }
        path.add(root.val);
        if(root.left ==null && root.right ==null){
            int sum = 0;
            for(Integer i:path){
                sum+=i;
            }
            if(sum==targetSum){
                flag = true;         
            }
             return;   
        }  
        dfs(root.left,targetSum,new ArrayList(path));
        dfs(root.right,targetSum,new ArrayList(path));
    }
}
//用集合，删除了
class Solution {
    boolean flag = false;
    public boolean hasPathSum(TreeNode root, int targetSum) {
        Deque<Integer> path =  new LinkedList<>();
        dfs(root,targetSum,path);
        return flag;


    }
    private void dfs(TreeNode root, int targetSum,Deque<Integer> path){
        if(root == null){
            return;
            
        }
        path.offer(root.val);
        if(root.left ==null && root.right ==null){
            int sum = 0;
            for(Integer i:path){
                sum+=i;
            }
            if(sum==targetSum){
                flag = true;
           
            }
             return; 
        };
        if(root.left !=null){dfs(root.left,targetSum,path);
        // if(!path.isEmpty())
        path.removeLast();
        }
        if(root.right !=null){dfs(root.right,targetSum,path);
        // if(!path.isEmpty())
        // path.remove(path.size()-1);
        path.removeLast();
        }
    }
}

//直接常量
class Solution {
    boolean flag = false;
    public int sum = 0;
    public boolean hasPathSum(TreeNode root, int targetSum) {
        // if(root == null)
        
        dfs(root,targetSum);
        return flag;


    }
    private void dfs(TreeNode root, int targetSum){
        if(root == null){
            return ;
        }
        sum+=root.val;
        if(root.left ==null && root.right ==null){
            if(sum==targetSum){
                flag = true;
            }
            return; 
        };
        if(root.left !=null){dfs(root.left,targetSum);
        // if(!path.isEmpty())
        
        sum=sum - root.left.val;
        }
        if(root.right !=null){dfs(root.right,targetSum);
        // if(!path.isEmpty())
        // path.remove(path.size()-1);
        sum= sum-root.right.val;
        }
    }
}
//递归版本
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root  == null){
            return false;
        }
        if(root.left ==null && root.right == null){
            return targetSum ==root.val;
        }
        return hasPathSum(root.left,targetSum-root.val)||hasPathSum(root.right,targetSum-root.val);
    }
}
```

### 6、分割回文串

[131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)

```java
class Solution {
     List<List<String>> res = new ArrayList<>();
    ArrayList<String> path = new ArrayList<>();
    public List<List<String>> partition(String s) {
        backtracking(s,0);
        return res;
    }
    private void backtracking(String s,int startIndex){
        if(startIndex == s.length()){
            res.add(new ArrayList(path));
            return ;
        }
        for(int i=startIndex;i<s.length();i++){
            if(isValid(s,startIndex,i)){
                path.add(s.substring(startIndex,i+1));
            }else{
                continue;
            }
             backtracking(s,i+1);
             path.remove(path.size()-1);
        }
    }
    private boolean isValid(String s,int startIndex,int endIndex){
        if(startIndex==endIndex){
            return true;
        }
        while(startIndex<endIndex){
            if(s.charAt(startIndex)!=s.charAt(endIndex)){
                return false;
            }
            startIndex++;
            endIndex--;
        }
        return true;
    }
}
```



### 7、复原IP地址

[93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

```java
class Solution {
     List<String> res = new ArrayList<>();
     List<Integer> path = new ArrayList<>();
    public List<String> restoreIpAddresses(String s) {
        backtracking(s,0,0);
        return res;
    }
    private void backtracking(String s,int startIndex,int sum){
        if(sum ==3 ){
            if(isVaild(s,startIndex,s.length()-1)){
                StringBuilder sb =  new StringBuilder();
                for(int i:path){
                    sb.append(i).append(".");
                }
                sb.append(s.substring(startIndex,s.length()));
                res.add(sb.toString());  
            } 
            return;
        }
        for(int i=startIndex;i<s.length();i++){
            if(isVaild(s,startIndex,i)){
                path.add(Integer.parseInt(s.substring(startIndex,i+1)));
                backtracking(s,i+1,sum+1);
                path.remove(path.size()-1);
            }else{
                continue;
            }
        }
    }
    private boolean isVaild(String s,int startIndex,int endIndex){
        if(startIndex >=s.length()){
            return false;
        }
        int digital = endIndex - startIndex + 1;
        if(digital !=1 && s.charAt(startIndex) =='0'){
            return false;
        }else if(digital <=2){
            return true;
        }else if(digital >=4){
            return false;
        }else{
            int num = Integer.parseInt(s.substring(startIndex,endIndex+1));
            if(num>=0 && num<=255){
                return true;
            }else{
                return false;
            }
        }
    }
}
```

### 8、子集

[78. 子集](https://leetcode-cn.com/problems/subsets/)

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    public List<List<Integer>> subsets(int[] nums) {
        // res.add(path);
        backtracking(nums,0);
        return res;
    }
    private void backtracking(int[] nums,int startIndex){
         res.add(new ArrayList(path));
        if(startIndex>=nums.length){
            return ;
        }
        for(int i=startIndex;i<nums.length;i++){
            path.add(nums[i]);
            backtracking(nums,i+1);
            path.remove(path.size()-1);
        }
    }
}
```



## 贪心

### 1、分发饼干

[分发饼干](https://leetcode-cn.com/problems/assign-cookies/)

```java
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        int i = 0,j =0;
        while(j<s.length && i<g.length){
            if(s[j] >= g[i]){
                i++;
            }
            j++;
            
        }
        return i;
    }
}
```

### 2、摆动序列

#### [摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)

```java
class Solution {
    public  int wiggleMaxLength(int[] nums) {
        if (nums.length <= 1) {
            return nums.length;
        }
        int pre = 0;
        int curr = 0;
        int count = 1;
        for (int i = 1; i < nums.length; i++) {
            curr = nums[i] - nums[i-1];
            if (pre <= 0 && curr > 0 || pre >= 0 && curr < 0) {
                count++;
                pre = curr;
            }
        }
        return count;
    }
}
```

### 3、卖卖股票的最佳时机II

#### [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

贪心：

```java
public int maxProfit(int[] prices) {
        if(prices.length <=1){
            return 0;
        }
        int res = 0;
        for(int i = 1;i<prices.length;i++){
            res += Math.max(prices[i] - prices[i-1],0);
        }
        return res;
    }
```

### 4、跳跃游戏

#### [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

换个思路想问题

```java

    public boolean canJump(int[] nums) {

        if(nums.length <= 1){
            return true;
        }
        int overRange = 0;
        for(int i=0;i<=overRange;i++){
            overRange = Math.max(overRange,i+nums[i]);
            if(overRange >=nums.length-1){
                return true;
            }
        }
        return false;

    }

```

### 5、跳跃游戏II

#### [45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)

```java
class Solution {
    public int jump(int[] nums) {
        if(nums.length <=1){
            return 0;
        }
        int count = 0;
        int currMax = 0;
        int nextMax = 0;
        for(int i=0;i<nums.length;i++){
            nextMax=Math.max(nextMax,i+nums[i]);
            if(nextMax >= nums.length-1){
                count++;
                return count;
            }
            if(i == currMax){
                currMax = nextMax;
                count++;
            }
        }
        return count;
    }  
}
```

### 6、K 次取反后最大化的数组和

#### [1005. K 次取反后最大化的数组和](https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/)

```java
class Solution {
    public int largestSumAfterKNegations(int[] nums, int k) {
       Arrays.sort(nums);
       int index =0;
       for(int i =0;i<nums.length;i++){
           if(nums[i]<0){
               index++;
           }
       }
       if(index ==0){
           for(int i =0;i< k;i++){
               nums[0] = -nums[0]; 
           }
       }else if(index >=k){
           for(int i =0;i<k;i++){
               nums[i] = -nums[i];
           }
       }else if(index < k){
           for(int i =0;i<index;i++){
               nums[i] = -nums[i];
           }
           Arrays.sort(nums);

           if((k-index) % 2 ==0){

           }else {
               nums[0] = -nums[0]; 
           }
           
       }
        
        
        return getSum(nums);
    }
    public int getSum(int[] nums){
        int res =0;
        for(int i:nums){
            res+= i;
        }
        return res;
    }
}
```

## 动态规划

### 1、买卖股票的最佳时机II

[122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

```java
class Solution {
    public int maxProfit(int[] prices) {
        int[][] dp = new int[prices.length][2];
        dp[0][0] = 0;
        dp[0][1] = -prices[0]; 
        for(int i=1;i<prices.length;i++){
            dp[i][0] = Math.max(dp[i-1][1]+prices[i],dp[i-1][0]);//没有股票
            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]-prices[i]);//有股票
        }
        return dp[prices.length-1][0];
    }
}
```

### 2、 加油站

#### [134. 加油站](https://leetcode-cn.com/problems/gas-station/)

```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int currSum = 0;
        int totalSum = 0;
        int index = 0;
        int[] dp = new int[gas.length];
        for(int i=0;i<gas.length;i++){
            dp[i] = gas[i] - cost[i];

        }
        for(int i=0;i<gas.length;i++){
            currSum += dp[i];
            totalSum += dp[i];
            if(currSum <0){
                // index = (i+1)%gas.length;
                index = i+1;
                currSum = 0;
            }

        }
        if(totalSum <0){return -1;}
        return index;
    }
}
```

```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int min = 0;
        int sum = 0;
        for(int i =0;i<gas.length;i++){
            sum += gas[i] - cost[i];
            min = Math.min(sum,min);

        }
        if(min >= 0){
            return 0;
        }
        if(sum<0){
            return -1;
        }
        for(int i=gas.length-1;i>0;i--){
            min += gas[i] - cost[i];
            if(min>=0){
                return i;
            }
        }
        return -1;

    }
}
```

## 好难的题

### 1、猜数字大小（记忆化递归）

#### [375. 猜数字大小 II](https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/)

```java
public int getMoneyAmount(int n) {
        int[][] dp = new int[n+1][n+1];

        return dps(dp,1,n);
    }
    private int dps(int[][] dp,int left,int right){
        if(left>=right){
            return 0;
        }
        int res = Integer.MAX_VALUE;
        if(dp[left][right] !=0){
            return dp[left][right];
        }
        for(int i=left;i<=right;i++){
            int cost  = i+ Math.max(dps(dp,left,i-1),dps(dp,i+1,right));

            res=Math.min(res,cost);

        }
        dp[left][right] = res;
        return res;
    }
```

### 2、用 Rand7() 实现 Rand10()

[【宫水三叶】k 进制诸位生成 + 拒绝采样](https://leetcode-cn.com/problems/implement-rand10-using-rand7/solution/gong-shui-san-xie-k-jin-zhi-zhu-wei-shen-zmd4/)

```java
class Solution extends SolBase {
    int num;
    public int rand10() {
        while(true){
            int num = (rand7()-1)*7+rand7()-1;
            if(num <40 &&num>=0){
                return num%10+1;
            }
        }
        
    }
}
rand5 ->rand7
class Solution {
    public int rand7() {
        while(true){
            int num = (rand5()-1)*5+rand5()-1;
            if(num <21 &&num>=0){
                return num%7+1;
            }
        }
        
    }
}
ran7->ran5
class Solution {
    public int rand5() {
        while(true){
            int num = rand7();
            if(num<=5){
                return num;
            }           
        }
    }
}



```



