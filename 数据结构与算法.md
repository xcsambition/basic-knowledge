## 数据结构与算法

数据结构：

- 队列
- 栈
- 并查集（哈希表）
- 数组
- 链表
- 二叉树
- 图

算法：

- 深度优先
- 广度优先
- 双指针
- 贪心算法
- 动态规划

## 栈和队列

### 1、用栈实现队列

```java
class MyQueue {
    Stack<Integer> stack1;
    Stack<Integer> stack2;


    public MyQueue() {
        stack1 = new Stack<>();
        stack2 = new Stack<>();
    }
    
    public void push(int x) {
        stack1.push(x);

    }
    
    public int pop() {
        if(stack2.isEmpty()){
            while(!stack1.isEmpty()){
                stack2.push(stack1.pop());
            }
        }
        return stack2.pop();
        


    }
    
    public int peek() {
        if(stack2.isEmpty()){
            while(!stack1.isEmpty()){
                stack2.push(stack1.pop());
            }
        }
        return stack2.peek();
    }
    
    public boolean empty() {
        if(stack2.isEmpty()){
            while(!stack1.isEmpty()){
                stack2.push(stack1.pop());
            }
        }
        return stack2.isEmpty();
    }
}
```





## 数组

## 链表

### 1、翻转链表

[翻转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

次数：5

递归：

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        
        return reverseList(null,head);
    }

    public ListNode reverseList(ListNode pre,ListNode curr) {
        if(curr !=null){         
                ListNode next = curr.next;
                curr.next = pre;
                return reverseList(curr,next);
        }
        return pre;
    }
}
```

迭代：

```java
class Solution {
    public ListNode reverseList(ListNode head) {

      
        ListNode curr = head;
        ListNode pre = null;
        ListNode next = null;
        while(curr!=null){
            next = curr.next;
            curr.next = pre;
            pre = curr;
            curr = next;
        }
        return pre;
    }
}
```





## 哈希表

## 双指针

### 1、三数之和

#### [15. 三数之和](https://leetcode-cn.com/problems/3sum/)

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums);
        for(int i=0;i<nums.length-2;i++){
            if(nums[i]>0){
                return result;
            }
            if(i>0 && nums[i] == nums[i-1]){
                continue;
            }



            int left = i+1;
            int right = nums.length-1;
            while(left<right){

                int sum = nums[i] +nums[left] +nums[right];
                if(sum >0){
                    right--;
                }else if(sum<0){
                    left++;
                }else{
                    result.add(Arrays.asList(nums[i],nums[left],nums[right]));
                    
                    while(left<right && nums[left] == nums[left+1]){
                        left++;
                    }
                    while(left<right && nums[right] == nums[right-1]){
                        right--;
                    }

                    right--;
                    left++;
                }
            }
        }
        return result;
    }
}
```



### 1、无重复字符的最长子串

#### [无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int max = 0;
        Set<Character> set = new HashSet<Character>();
        char[] chars = s.toCharArray();
        for(int right=0,left=0;right<chars.length;){
            if(set.contains(chars[right])){        
                set.remove(chars[left]);
                left++;
            }else{
            set.add(chars[right]);
            right++;
            }
             max = Math.max(right-left,max);
        }
        return max;
    }
}
```

### 2、盛最多水的容器

#### [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

```java
class Solution {
    public int maxArea(int[] height) {
        int right =0;
        int left = height.length-1;
        int max=0;
        while(right< left){
            int min = Math.min(height[left],height[right]);
            max = Math.max((left-right)*min,max);
            if(height[right]<height[left]){
                right++;
            }else{
                left--;
            }
            while(height[left]<=min &&right<left){
            --left;
            }
            while(height[right]<=min &&right<left){
                ++right;
            }
        }
        return max;
    }
}
```





## 二叉树

### 迭代遍历

#### 前序遍历：

#### [二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<>();
     if (root == null){
            return res;
    }
    Stack<TreeNode> stack = new Stack<>();
    // Deque<TreeNode> stack = new LinkedList<>();
    // stack.push(root);
    while(root!=null || !stack.isEmpty()){
        
        if(root !=null){
            res.add(root.val);
            stack.push(root);
            root =root.left;
            
        }else{
            root = stack.pop().right;
        }
    }
    return res;
    }
}
```



#### 中序遍历：

[二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

次数：4

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root ==null){
            return res;
        }
        Stack<TreeNode> stack = new Stack<>();
        TreeNode curr = root;
        while(curr!=null || !stack.isEmpty()){
            if(curr!=null){
                stack.push(curr);
                curr = curr.left;
            } else {
                curr = stack.pop();
                res.add(curr.val);
                curr = curr.right;
            }
        }
        return res;
    }
}
```

#### 后序遍历：

[二叉树后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

次数：1

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        Deque<TreeNode> stack = new LinkedList<>();
        List<Integer> list = new ArrayList<>();
        Set<TreeNode> set = new HashSet<>();
        while(root != null || !stack.isEmpty()){
            if(root != null){
                stack.push(root);
                root = root.left;
            }else if(root == null && set.contains(stack.peek())){
                list.add(stack.pop().val);
                // root = stack.peek().right;
                //仔细思考为什么这里开始写了，其实就是根据null一直判断栈里面有之前遍历的数据
            }else{
                set.add(stack.peek());
                root = stack.peek().right;
            }
        }
        return list;
    }
}
```

## 回溯

## 贪心

### 1、分发饼干

[分发饼干](https://leetcode-cn.com/problems/assign-cookies/)

```java
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        int i = 0,j =0;
        while(j<s.length && i<g.length){
            if(s[j] >= g[i]){
                i++;
            }
            j++;
            
        }
        return i;
    }
}
```

### 2、摆动序列

#### [摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)

```java
class Solution {
    public  int wiggleMaxLength(int[] nums) {
        if (nums.length <= 1) {
            return nums.length;
        }
        int pre = 0;
        int curr = 0;
        int count = 1;
        for (int i = 1; i < nums.length; i++) {
            curr = nums[i] - nums[i-1];
            if (pre <= 0 && curr > 0 || pre >= 0 && curr < 0) {
                count++;
                pre = curr;
            }
        }
        return count;
    }
}
```

### 3、卖卖股票的最佳时机II

#### [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

贪心：

```java
public int maxProfit(int[] prices) {
        if(prices.length <=1){
            return 0;
        }
        int res = 0;
        for(int i = 1;i<prices.length;i++){
            res += Math.max(prices[i] - prices[i-1],0);
        }
        return res;
    }
```

### 4、跳跃游戏

#### [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

换个思路想问题

```java

    public boolean canJump(int[] nums) {

        if(nums.length <= 1){
            return true;
        }
        int overRange = 0;
        for(int i=0;i<=overRange;i++){
            overRange = Math.max(overRange,i+nums[i]);
            if(overRange >=nums.length-1){
                return true;
            }
        }
        return false;

    }

```

### 5、跳跃游戏II

#### [45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)

```java
class Solution {
    public int jump(int[] nums) {
        if(nums.length <=1){
            return 0;
        }
        int count = 0;
        int currMax = 0;
        int nextMax = 0;
        for(int i=0;i<nums.length;i++){
            nextMax=Math.max(nextMax,i+nums[i]);
            if(nextMax >= nums.length-1){
                count++;
                return count;
            }
            if(i == currMax){
                currMax = nextMax;
                count++;
            }
        }
        return count;
    }  
}
```

### 6、K 次取反后最大化的数组和

#### [1005. K 次取反后最大化的数组和](https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/)

```java
class Solution {
    public int largestSumAfterKNegations(int[] nums, int k) {
       Arrays.sort(nums);
       int index =0;
       for(int i =0;i<nums.length;i++){
           if(nums[i]<0){
               index++;
           }
       }
       if(index ==0){
           for(int i =0;i< k;i++){
               nums[0] = -nums[0]; 
           }
       }else if(index >=k){
           for(int i =0;i<k;i++){
               nums[i] = -nums[i];
           }
       }else if(index < k){
           for(int i =0;i<index;i++){
               nums[i] = -nums[i];
           }
           Arrays.sort(nums);

           if((k-index) % 2 ==0){

           }else {
               nums[0] = -nums[0]; 
           }
           
       }
        
        
        return getSum(nums);
    }
    public int getSum(int[] nums){
        int res =0;
        for(int i:nums){
            res+= i;
        }
        return res;
    }
}
```



### 1、买卖股票的最佳时机II

[122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

```java
class Solution {
    public int maxProfit(int[] prices) {
        int[][] dp = new int[prices.length][2];
        dp[0][0] = 0;
        dp[0][1] = -prices[0]; 
        for(int i=1;i<prices.length;i++){
            dp[i][0] = Math.max(dp[i-1][1]+prices[i],dp[i-1][0]);//没有股票
            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]-prices[i]);//有股票
        }
        return dp[prices.length-1][0];
    }
}
```

### 7、 加油站

#### [134. 加油站](https://leetcode-cn.com/problems/gas-station/)

```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int currSum = 0;
        int totalSum = 0;
        int index = 0;
        int[] dp = new int[gas.length];
        for(int i=0;i<gas.length;i++){
            dp[i] = gas[i] - cost[i];

        }
        for(int i=0;i<gas.length;i++){
            currSum += dp[i];
            totalSum += dp[i];
            if(currSum <0){
                // index = (i+1)%gas.length;
                index = i+1;
                currSum = 0;
            }

        }
        if(totalSum <0){return -1;}
        return index;
    }
}
```

```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int min = 0;
        int sum = 0;
        for(int i =0;i<gas.length;i++){
            sum += gas[i] - cost[i];
            min = Math.min(sum,min);

        }
        if(min >= 0){
            return 0;
        }
        if(sum<0){
            return -1;
        }
        for(int i=gas.length-1;i>0;i--){
            min += gas[i] - cost[i];
            if(min>=0){
                return i;
            }
        }
        return -1;

    }
}
```

